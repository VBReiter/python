__author__ = 'Рейтер Валерия Борисовна'

# 1. Реализовать класс «Дата».
# Техническое задание:
#
# Конструктор принимает дату (параметр) в виде строки формата «день-месяц-год».
# Методы объекта:
# Первый с декоратором @classmethod. Извлекает число, месяц, год из строки «день-месяц-год», преобразовывает их к типу
# int. Возвращает три числа.
# Второй с декоратором @staticmethod. Проводит валидацию этих трех чисел, например, месяц — от 1 до 12, дней в месяце
# не более 31 - далее на ваш выбор. Вы можете использовать пакет datetime для проверки корректности даты. Подумайте что
# логично возвращать валидатору, какое значимое имя вы дадите этому методу?
# При создании объекта в конструкторе использовать оба указанных метода.
# Конструктор создает объект только если прошла валидация вторым методом.
# Объект «дата» хранится в виде трех чисел отдельно или в контейнере. В случае невозможности создать объект контруктор
# выкидывает исключение DateInitError c внятным диагностическим сообщением.
# Переопределить метод __str__ для печати числа в виде 2021.12.31
# Создать несколько экземпляров и распечатать их. Проверить работу на не валидных данных.
# Исключение от конструктора ловить в основном коде программы и подменять выводом диагностического сообщения (любого).
# Примеры/Тесты:
#
#
# >>> lst_date = ["31-12-2021", "32-12-2022", "12-12&##x2013;2022" ]
# ...
# 2021.12.31
# Дата: 32-12-2022,  результат: Внятное диагностическое сообщение
# Дата: 12-12--2022, результат: Внятное диагностическое сообщение
# >>>
#
# Примечание:
#
# В задании предполагаем что оба метода используются только для конструктора. Внутренние проверки вы можете сделать на
# основе концепций LBYL(проверки и обход «узких» мест) или EAFP(исключения и их обработка).
# Подумайте что логично возвращать методам в случае обоих концепций?
from datetime import date


class DateInitError(Exception): pass


class Date:

    def __init__(self, new_date):
        parts_date = self.__class__.convert_date(new_date)
        if self.__class__.check_is_date(parts_date):
            self.new_date = new_date
            self.parts_date = parts_date
        else:
            raise DateInitError

    @classmethod
    def convert_date(cls, new_date):
        if "-" in new_date:
            t_date = new_date.split("-")
            for i, td in enumerate(t_date):
                try:
                    t_date[i] = int(td)
                except ValueError:
                    return new_date
            return t_date
        else:
            return new_date

    @staticmethod
    def check_is_date(t_date):
        if isinstance(t_date, list):
            day, month, year = t_date
            try:
                date(year, month, day)
            except ValueError:
                return False
            else:
                return True
        else:
            return False

    def __str__(self):
        return f"{self.parts_date[2]}.{self.parts_date[1]}.{self.parts_date[0]}"


lst_date = ["31-12-2021", "32-12-2022", "12-12&##x2013;2022"]
for i in lst_date:
    try:
        d1 = Date(i)
    except DateInitError:
        print(f"Дата: {i},  результат: Выражение не является датой")
    else:
        print(d1)
